diff --git a/kernel/kern/scheduler.cpp b/kernel/kern/scheduler.cpp
index 24d8d031..4db25772 100644
--- a/kernel/kern/scheduler.cpp
+++ b/kernel/kern/scheduler.cpp
@@ -81,6 +81,42 @@ namespace scheduler
                 What::onRunQueue, What::onSleepQueue, onRunQueue, onSleepQueue);
         }
 
+        enum class EventType  {
+            Unused, Resume, Suspend, Release, SwitchTo
+        };
+
+        struct Event  {
+            EventType type{EventType::Unused};
+            Thread* thread{};
+            Thread* curthread{};
+            int cpu{-1};
+        };
+
+        util::array<Event, 1'000> eventLog;
+        size_t currentEventIndex = 0;
+
+        // Must be called with schedLock held
+        void LogEvent(Event e)
+        {
+            e.cpu = PCPU_GET(cpuid);
+            eventLog[currentEventIndex] = e;
+            currentEventIndex = (currentEventIndex + 1) % eventLog.size();
+        }
+
+        void PrintEventLog()
+        {
+            constexpr util::array<const char*, 5> eventNames{ "unused", "resume", "suspend", "release", "switchto" };
+
+            int n = currentEventIndex;
+            do {
+                --n; if (n < 0) n = eventLog.size() - 1;
+
+                auto& ev = eventLog[n];
+                kprintf("event %d: %s cpu %d thread %p curthread %p\n",
+                    n, eventNames[static_cast<int>(ev.type)], ev.cpu, ev.thread, ev.curthread);
+            } while(n != currentEventIndex);
+        }
+
         // Must be called with schedLock held
         void AddThreadToRunQueue(Thread& t)
         {
@@ -113,16 +149,17 @@ namespace scheduler
             AddThreadToRunQueue(t);
             t.t_sched_flags &= ~THREAD_SCHED_SUSPENDED;
             t.t_flags &= ~THREAD_FLAG_TIMEOUT;
+            LogEvent({ EventType::Resume, &t, &thread::GetCurrent() });
         }
 
         // Must be called with schedLock held
-        Thread& PickNextThreadToSchedule(Thread* curthread, const int cpuid)
+        Thread& PickNextThreadToSchedule(Thread& curThread, const int cpuid)
         {
             KASSERT(!sched_runqueue.empty(), "runqueue cannot be empty");
             for (auto& t : sched_runqueue) {
                 if (t.t_affinity != THREAD_AFFINITY_ANY && t.t_affinity != cpuid)
                     continue; // not possible on this CPU
-                if (t.IsActive() && &t != curthread)
+                if (t.IsActive() && &t != &curThread)
                     continue;
                 return t;
             }
@@ -155,6 +192,7 @@ namespace scheduler
             // New threads are initially suspended
             t.t_sched_flags = THREAD_SCHED_SUSPENDED;
             sched_sleepqueue.push_back(t);
+            LogEvent({ EventType::Suspend, &t, &thread::GetCurrent() });
         }
     }
 
@@ -185,6 +223,7 @@ namespace scheduler
         sched_runqueue.remove(t);
         AddThreadToSleepQueue(t);
         t.t_sched_flags |= THREAD_SCHED_SUSPENDED;
+        LogEvent({ EventType::Suspend, &t, &thread::GetCurrent() });
     }
 
     void ExitThread(Thread& t)
@@ -219,13 +258,13 @@ namespace scheduler
 
         /* Release the old thread; it is now safe to schedule it elsewhere */
         old->t_sched_flags &= ~THREAD_SCHED_ACTIVE;
+        LogEvent({ EventType::Release, old, &thread::GetCurrent() });
     }
 
     void Schedule()
     {
-        Thread* curthread = PCPU_GET(curthread);
+        auto& curThread = thread::GetCurrent();
         const int cpuid = PCPU_GET(cpuid);
-        KASSERT(curthread != NULL, "no current thread active");
 
         /*
          * Grab the scheduler lock and disable interrupts; note that they need not be
@@ -235,7 +274,7 @@ namespace scheduler
         auto state = schedLock.LockUnpremptible();
 
         // Cancel any rescheduling as we are about to schedule here
-        curthread->t_flags &= ~THREAD_FLAG_RESCHEDULE;
+        curThread.t_flags &= ~THREAD_FLAG_RESCHEDULE;
 
         /*
          * See if the first item on the sleepqueue is worth waking up; we'll only
@@ -244,14 +283,14 @@ namespace scheduler
         WakeupSleepingThreads();
 
         // Pick the next thread to schedule
-        auto& newthread = PickNextThreadToSchedule(curthread, cpuid);
+        auto& newThread = PickNextThreadToSchedule(curThread, cpuid);
 
         // Sanity checks
-        KASSERT(!newthread.IsSuspended(), "activating suspended thread %p", &newthread);
+        KASSERT(!newThread.IsSuspended(), "activating suspended thread %p", &newThread);
         KASSERT(
-            &newthread == curthread || !newthread.IsActive(), "activating active thread %p",
-            &newthread);
-        Prove<OnlyOnRunQueue>(newthread);
+            &newThread == &curThread || !newThread.IsActive(), "activating active thread %p",
+            &newThread);
+        Prove<OnlyOnRunQueue>(newThread);
 
         /*
          * If the current thread is not suspended, this means it got interrupted
@@ -262,23 +301,24 @@ namespace scheduler
          * We must also take care not to re-add zombie threads; these must not be
          * re-added to either scheduler queue.
          */
-        if (!curthread->IsSuspended() && !curthread->IsZombie()) {
-            sched_runqueue.remove(*curthread);
-            AddThreadToRunQueue(*curthread);
+        if (!curThread.IsSuspended() && !curThread.IsZombie()) {
+            sched_runqueue.remove(curThread);
+            AddThreadToRunQueue(curThread);
         }
 
         /*
          * Schedule our new thread; by marking it as active, it will not be picked up by another
          * CPU.
          */
-        newthread.t_sched_flags |= THREAD_SCHED_ACTIVE;
-        PCPU_SET(curthread, &newthread);
+        newThread.t_sched_flags |= THREAD_SCHED_ACTIVE;
+        PCPU_SET(curthread, &newThread);
+        LogEvent({ EventType::SwitchTo, &newThread, &curThread });
 
         // Now unlock the scheduler lock but do _not_ enable interrupts
         schedLock.Unlock();
 
-        if (curthread != &newthread) {
-            Thread& prev = md::thread::SwitchTo(newthread, *curthread);
+        if (&curThread != &newThread) {
+            auto& prev = md::thread::SwitchTo(newThread, curThread);
             scheduler_release(&prev);
         }
 
@@ -289,7 +329,7 @@ namespace scheduler
     void Launch()
     {
         Thread* idlethread = PCPU_GET(idlethread);
-        KASSERT(PCPU_GET(curthread) == idlethread, "idle thread not correct");
+        KASSERT(&thread::GetCurrent() == idlethread, "idle thread not correct");
 
         /*
          * Activate the idle thread; the MD startup code should have done the
@@ -340,4 +380,9 @@ const kdb::RegisterCommand
             kdbPrintThread(s);
         }
     });
-#endif /* OPTION_KDB */
+
+const kdb::RegisterCommand
+    kdbSchedulerLog("schedlog", "Display scheduler log", [](int, const kdb::Argument*) {
+        scheduler::PrintEventLog();
+    });
+#endif /* OPTION_KDB */
\ No newline at end of file
